// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Gov.Lclb.Cllb.Interfaces.GeoCoder
{
    using Microsoft.Rest;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// GeoCoderAPI operations.
    /// </summary>
    public partial class GeoCoderAPI : IServiceOperations<GeocoderClient>, IGeoCoderAPI
    {
        /// <summary>
        /// Initializes a new instance of the GeoCoderAPI class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public GeoCoderAPI(GeocoderClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the GeocoderClient
        /// </summary>
        public GeocoderClient Client { get; private set; }

        /// <summary>
        /// Geocode an address
        /// </summary>
        /// <remarks>
        /// Represents the set of geocoded and standardized sites and intersections
        /// whose address best matches a given query address.
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='addressString'>
        /// Civic or intersection address as a single string. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#addressString
        /// target="_blank"&gt;addressString&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='interpolation'>
        /// accessPoint interpolation method. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#interpolation
        /// target="_blank"&gt;interpolation&lt;/a&gt;. Possible values include:
        /// 'adaptive', 'linear', 'none'
        /// </param>
        /// <param name='echo'>
        /// If true, include unmatched address details such as site name in results.
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='autoComplete'>
        /// If true, addressString is expected to contain a partial address that
        /// requires completion. Not supported for shp, csv, gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='minScore'>
        /// The minimum score required for a match to be returned. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#minScore
        /// target="_blank"&gt;minScore&lt;/a&gt;
        /// </param>
        /// <param name='matchPrecision'>
        /// Example: street,locality.  A comma separated list of individual match
        /// precision levels to include in results. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#matchPrecision
        /// target="_blank"&gt;matchPrecision&lt;/a&gt;
        /// </param>
        /// <param name='matchPrecisionNot'>
        /// Example: street,locality.  A comma separated list of individual match
        /// precision levels to exclude from results. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#matchPrecisionNot
        /// target="_blank"&gt;matchPrecisionNot&lt;/a&gt;
        /// </param>
        /// <param name='siteName'>
        /// A string containing the name of the building, facility, or institution
        /// (e.g., Duck Building, Casa Del Mar, Crystal Garden, Bluebird House).See
        /// &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#siteName
        /// target="_blank"&gt;siteName&lt;/a&gt;
        /// </param>
        /// <param name='unitDesignator'>
        /// The type of unit within a house or building. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#unitDesignator
        /// target="_blank"&gt;unitDesignator&lt;/a&gt;. Possible values include:
        /// 'APT', 'BLDG', 'BSMT', 'FLR', 'LOBBY', 'LWR', 'PAD', 'PH', 'REAR', 'RM',
        /// 'SIDE', 'SITE', 'SUITE', 'TH', 'UNIT', 'UPPR'
        /// </param>
        /// <param name='unitNumber'>
        /// The number of the unit, suite, or apartment within a house or building.
        /// </param>
        /// <param name='unitNumberSuffix'>
        /// A letter that follows the unit number as in Unit 1A or Suite 302B.
        /// </param>
        /// <param name='civicNumber'>
        /// The official number assigned to a site by an address authority. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#civicNumber
        /// target="_blank"&gt;civicNumber&lt;/a&gt;
        /// </param>
        /// <param name='civicNumberSuffix'>
        /// A letter or fraction that follows the civic number (e.g., the A in 1039A
        /// Bledsoe St). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#civicNumberSuffix
        /// target="_blank"&gt;civicNumberSuffix&lt;/a&gt;
        /// </param>
        /// <param name='streetName'>
        /// The official name of the street as assigned by an address authority (e.g.,
        /// the Douglas in 1175 Douglas Street). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetName
        /// target="_blank"&gt;streetName&lt;/a&gt;
        /// </param>
        /// <param name='streetType'>
        /// The type of street as assigned by a municipality (e.g., the ST in 1175
        /// DOUGLAS St). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetType
        /// target="_blank"&gt;streetType&lt;/a&gt;
        /// </param>
        /// <param name='streetDirection'>
        /// The abbreviated compass direction as defined by Canada Post and B.C. civic
        /// addressing authorities. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetDirection
        /// target="_blank"&gt;streetDirection&lt;/a&gt;. Possible values include: 'N',
        /// 'S', 'E', 'W', 'O', 'NE', 'NO', 'NW', 'SE', 'SO', 'SW'
        /// </param>
        /// <param name='streetQualifier'>
        /// Example: the Bridge in Johnson St Bridge. The qualifier of a street name.
        /// See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetQualifier
        /// target="_blank"&gt;streetQualifier&lt;/a&gt;
        /// </param>
        /// <param name='localityName'>
        /// The name of the locality assigned to a given site by an address authority.
        /// See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#localityName
        /// target="_blank"&gt;localityName&lt;/a&gt;
        /// </param>
        /// <param name='provinceCode'>
        /// The ISO 3166-2 Sub-Country Code. The code for British Columbia is BC.
        /// </param>
        /// <param name='localities'>
        /// A comma separated list of locality names that matched addresses must belong
        /// to. For example, setting localities to Nanaimo only returns addresses in
        /// Nanaimo
        /// </param>
        /// <param name='notLocalities'>
        /// A comma-separated list of localities to exclude from the search.
        /// </param>
        /// <param name='bbox'>
        /// Example: -126.07929,49.7628,-126.0163,49.7907.  A bounding box
        /// (xmin,ymin,xmax,ymax) that limits the search area. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#bbox
        /// target="_blank"&gt;bbox&lt;/a&gt;
        /// </param>
        /// <param name='centre'>
        /// Example: -124.0165926,49.2296251 .  The coordinates of a centre point (x,y)
        /// used to define a bounding circle that will limit the search area. This
        /// parameter must be specified together with 'maxDistance'. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#centre
        /// target='_blank'&gt;centre&lt;/a&gt;
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='extrapolate'>
        /// If true, uses supplied parcelPoint to derive an appropriate accessPoint.
        /// See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#extrapolate
        /// target="_blank"&gt;extrapolate&lt;/a&gt;
        /// </param>
        /// <param name='parcelPoint'>
        /// The coordinates of a point (x,y) known to be inside the parcel containing a
        /// given address. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#parcelPoint
        /// target="_blank"&gt;parcelPoint&lt;/a&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> SitesWithHttpMessagesAsync(string outputFormat, string addressString = default(string), string locationDescriptor = default(string), int? maxResults = 1, string interpolation = default(string), bool? echo = true, bool? brief = false, bool? autoComplete = false, int? setBack = 0, int? outputSRS = 4326, int? minScore = 1, string matchPrecision = default(string), string matchPrecisionNot = default(string), string siteName = default(string), string unitDesignator = default(string), string unitNumber = default(string), string unitNumberSuffix = default(string), string civicNumber = default(string), string civicNumberSuffix = default(string), string streetName = default(string), string streetType = default(string), string streetDirection = default(string), string streetQualifier = default(string), string localityName = default(string), string provinceCode = "BC", string localities = default(string), string notLocalities = default(string), string bbox = default(string), string centre = default(string), double? maxDistance = default(double?), bool? extrapolate = default(bool?), string parcelPoint = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("addressString", addressString);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("interpolation", interpolation);
                tracingParameters.Add("echo", echo);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("autoComplete", autoComplete);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("minScore", minScore);
                tracingParameters.Add("matchPrecision", matchPrecision);
                tracingParameters.Add("matchPrecisionNot", matchPrecisionNot);
                tracingParameters.Add("siteName", siteName);
                tracingParameters.Add("unitDesignator", unitDesignator);
                tracingParameters.Add("unitNumber", unitNumber);
                tracingParameters.Add("unitNumberSuffix", unitNumberSuffix);
                tracingParameters.Add("civicNumber", civicNumber);
                tracingParameters.Add("civicNumberSuffix", civicNumberSuffix);
                tracingParameters.Add("streetName", streetName);
                tracingParameters.Add("streetType", streetType);
                tracingParameters.Add("streetDirection", streetDirection);
                tracingParameters.Add("streetQualifier", streetQualifier);
                tracingParameters.Add("localityName", localityName);
                tracingParameters.Add("provinceCode", provinceCode);
                tracingParameters.Add("localities", localities);
                tracingParameters.Add("notLocalities", notLocalities);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("centre", centre);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("extrapolate", extrapolate);
                tracingParameters.Add("parcelPoint", parcelPoint);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "addresses.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (addressString != null)
            {
                _queryParameters.Add(string.Format("addressString={0}", System.Uri.EscapeDataString(addressString)));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (interpolation != null)
            {
                _queryParameters.Add(string.Format("interpolation={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(interpolation, Client.SerializationSettings).Trim('"'))));
            }
            if (echo != null)
            {
                _queryParameters.Add(string.Format("echo={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(echo, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (autoComplete != null)
            {
                _queryParameters.Add(string.Format("autoComplete={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(autoComplete, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (minScore != null)
            {
                _queryParameters.Add(string.Format("minScore={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(minScore, Client.SerializationSettings).Trim('"'))));
            }
            if (matchPrecision != null)
            {
                _queryParameters.Add(string.Format("matchPrecision={0}", System.Uri.EscapeDataString(matchPrecision)));
            }
            if (matchPrecisionNot != null)
            {
                _queryParameters.Add(string.Format("matchPrecisionNot={0}", System.Uri.EscapeDataString(matchPrecisionNot)));
            }
            if (siteName != null)
            {
                _queryParameters.Add(string.Format("siteName={0}", System.Uri.EscapeDataString(siteName)));
            }
            if (unitDesignator != null)
            {
                _queryParameters.Add(string.Format("unitDesignator={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(unitDesignator, Client.SerializationSettings).Trim('"'))));
            }
            if (unitNumber != null)
            {
                _queryParameters.Add(string.Format("unitNumber={0}", System.Uri.EscapeDataString(unitNumber)));
            }
            if (unitNumberSuffix != null)
            {
                _queryParameters.Add(string.Format("unitNumberSuffix={0}", System.Uri.EscapeDataString(unitNumberSuffix)));
            }
            if (civicNumber != null)
            {
                _queryParameters.Add(string.Format("civicNumber={0}", System.Uri.EscapeDataString(civicNumber)));
            }
            if (civicNumberSuffix != null)
            {
                _queryParameters.Add(string.Format("civicNumberSuffix={0}", System.Uri.EscapeDataString(civicNumberSuffix)));
            }
            if (streetName != null)
            {
                _queryParameters.Add(string.Format("streetName={0}", System.Uri.EscapeDataString(streetName)));
            }
            if (streetType != null)
            {
                _queryParameters.Add(string.Format("streetType={0}", System.Uri.EscapeDataString(streetType)));
            }
            if (streetDirection != null)
            {
                _queryParameters.Add(string.Format("streetDirection={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(streetDirection, Client.SerializationSettings).Trim('"'))));
            }
            if (streetQualifier != null)
            {
                _queryParameters.Add(string.Format("streetQualifier={0}", System.Uri.EscapeDataString(streetQualifier)));
            }
            if (localityName != null)
            {
                _queryParameters.Add(string.Format("localityName={0}", System.Uri.EscapeDataString(localityName)));
            }
            if (provinceCode != null)
            {
                _queryParameters.Add(string.Format("provinceCode={0}", System.Uri.EscapeDataString(provinceCode)));
            }
            if (localities != null)
            {
                _queryParameters.Add(string.Format("localities={0}", System.Uri.EscapeDataString(localities)));
            }
            if (notLocalities != null)
            {
                _queryParameters.Add(string.Format("notLocalities={0}", System.Uri.EscapeDataString(notLocalities)));
            }
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (centre != null)
            {
                _queryParameters.Add(string.Format("centre={0}", System.Uri.EscapeDataString(centre)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (extrapolate != null)
            {
                _queryParameters.Add(string.Format("extrapolate={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(extrapolate, Client.SerializationSettings).Trim('"'))));
            }
            if (parcelPoint != null)
            {
                _queryParameters.Add(string.Format("parcelPoint={0}", System.Uri.EscapeDataString(parcelPoint)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Geocode an address and identify site occupants
        /// </summary>
        /// <remarks>
        /// Represents the set of occupants whose addresses best match a given query
        /// address. Every occupant has an associated site which has a standardized
        /// address and a coordinate location on the Earth.
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='addressString'>
        /// Occupant name OR Occupant name ** address
        /// </param>
        /// <param name='tags'>
        /// Example: schools;courts;employment&lt;br&gt;A list of tags separated by
        /// semicolons.
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='interpolation'>
        /// accessPoint interpolation method. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#interpolation
        /// target="_blank"&gt;interpolation&lt;/a&gt;. Possible values include:
        /// 'adaptive', 'linear', 'none'
        /// </param>
        /// <param name='echo'>
        /// If true, include unmatched address details such as site name in results.
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='autoComplete'>
        /// If true, addressString is expected to contain a partial address that
        /// requires completion. Not supported for shp, csv, gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='minScore'>
        /// The minimum score required for a match to be returned. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#minScore
        /// target="_blank"&gt;minScore&lt;/a&gt;
        /// </param>
        /// <param name='matchPrecision'>
        /// Example: street,locality.  A comma separated list of individual match
        /// precision levels to include in results. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#matchPrecision
        /// target="_blank"&gt;matchPrecision&lt;/a&gt;
        /// </param>
        /// <param name='matchPrecisionNot'>
        /// Example: street,locality.  A comma separated list of individual match
        /// precision levels to exclude from results. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#matchPrecisionNot
        /// target="_blank"&gt;matchPrecisionNot&lt;/a&gt;
        /// </param>
        /// <param name='siteName'>
        /// A string containing the name of the building, facility, or institution
        /// (e.g., Duck Building, Casa Del Mar, Crystal Garden, Bluebird House).See
        /// &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#siteName
        /// target="_blank"&gt;siteName&lt;/a&gt;
        /// </param>
        /// <param name='unitDesignator'>
        /// The type of unit within a house or building. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#unitDesignator
        /// target="_blank"&gt;unitDesignator&lt;/a&gt;. Possible values include:
        /// 'APT', 'BLDG', 'BSMT', 'FLR', 'LOBBY', 'LWR', 'PAD', 'PH', 'REAR', 'RM',
        /// 'SIDE', 'SITE', 'SUITE', 'TH', 'UNIT', 'UPPR'
        /// </param>
        /// <param name='unitNumber'>
        /// The number of the unit, suite, or apartment within a house or building.
        /// </param>
        /// <param name='unitNumberSuffix'>
        /// A letter that follows the unit number as in Unit 1A or Suite 302B.
        /// </param>
        /// <param name='civicNumber'>
        /// The official number assigned to a site by an address authority. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#civicNumber
        /// target="_blank"&gt;civicNumber&lt;/a&gt;
        /// </param>
        /// <param name='civicNumberSuffix'>
        /// A letter or fraction that follows the civic number (e.g., the A in 1039A
        /// Bledsoe St). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#civicNumberSuffix
        /// target="_blank"&gt;civicNumberSuffix&lt;/a&gt;
        /// </param>
        /// <param name='streetName'>
        /// The official name of the street as assigned by an address authority (e.g.,
        /// the Douglas in 1175 Douglas Street). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetName
        /// target="_blank"&gt;streetName&lt;/a&gt;
        /// </param>
        /// <param name='streetType'>
        /// The type of street as assigned by a municipality (e.g., the ST in 1175
        /// DOUGLAS St). See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetType
        /// target="_blank"&gt;streetType&lt;/a&gt;
        /// </param>
        /// <param name='streetDirection'>
        /// The abbreviated compass direction as defined by Canada Post and B.C. civic
        /// addressing authorities. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetDirection
        /// target="_blank"&gt;streetDirection&lt;/a&gt;. Possible values include: 'N',
        /// 'S', 'E', 'W', 'O', 'NE', 'NO', 'NW', 'SE', 'SO', 'SW'
        /// </param>
        /// <param name='streetQualifier'>
        /// The qualifier of a street name (e.g., the Bridge in Johnson St Bridge)
        /// </param>
        /// <param name='localityName'>
        /// The name of the locality assigned to a given site by an address authority.
        /// See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#streetDirection
        /// target="_blank"&gt;streetDirection&lt;/a&gt;
        /// </param>
        /// <param name='provinceCode'>
        /// The ISO 3166-2 Sub-Country Code. The code for British Columbia is BC.
        /// </param>
        /// <param name='localities'>
        /// A comma separated list of locality names that matched addresses must belong
        /// to. For example, setting localities to Nanaimo only returns addresses in
        /// Nanaimo
        /// </param>
        /// <param name='notLocalities'>
        /// A comma-separated list of localities to exclude from the search.
        /// </param>
        /// <param name='bbox'>
        /// Example: -126.07929,49.7628,-126.0163,49.7907.  A bounding box
        /// (xmin,ymin,xmax,ymax) that limits the search area. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#bbox
        /// target="_blank"&gt;bbox&lt;/a&gt;
        /// </param>
        /// <param name='centre'>
        /// Example: -124.0165926,49.2296251 .  The coordinates of a centre point (x,y)
        /// used to define a bounding circle that will limit the search area. This
        /// parameter must be specified together with 'maxDistance'. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#centre
        /// target='_blank'&gt;centre&lt;/a&gt;
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='extrapolate'>
        /// If true, uses supplied parcelPoint to derive an appropriate accessPoint.
        /// See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#extrapolate
        /// target="_blank"&gt;extrapolate&lt;/a&gt;
        /// </param>
        /// <param name='parcelPoint'>
        /// The coordinates of a point (x,y) known to be inside the parcel containing a
        /// given address. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#parcelPoint
        /// target="_blank"&gt;parcelPoint&lt;/a&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> OccupantsWithHttpMessagesAsync(string outputFormat, string addressString = default(string), string tags = default(string), string locationDescriptor = default(string), int? maxResults = 1, string interpolation = default(string), bool? echo = false, bool? brief = false, bool? autoComplete = false, int? setBack = 0, int? outputSRS = 4326, int? minScore = 1, string matchPrecision = "OCCUPANT", string matchPrecisionNot = default(string), string siteName = default(string), string unitDesignator = default(string), string unitNumber = default(string), string unitNumberSuffix = default(string), string civicNumber = default(string), string civicNumberSuffix = default(string), string streetName = default(string), string streetType = default(string), string streetDirection = default(string), string streetQualifier = default(string), string localityName = default(string), string provinceCode = "BC", string localities = default(string), string notLocalities = default(string), string bbox = default(string), string centre = default(string), double? maxDistance = default(double?), bool? extrapolate = default(bool?), string parcelPoint = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("addressString", addressString);
                tracingParameters.Add("tags", tags);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("interpolation", interpolation);
                tracingParameters.Add("echo", echo);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("autoComplete", autoComplete);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("minScore", minScore);
                tracingParameters.Add("matchPrecision", matchPrecision);
                tracingParameters.Add("matchPrecisionNot", matchPrecisionNot);
                tracingParameters.Add("siteName", siteName);
                tracingParameters.Add("unitDesignator", unitDesignator);
                tracingParameters.Add("unitNumber", unitNumber);
                tracingParameters.Add("unitNumberSuffix", unitNumberSuffix);
                tracingParameters.Add("civicNumber", civicNumber);
                tracingParameters.Add("civicNumberSuffix", civicNumberSuffix);
                tracingParameters.Add("streetName", streetName);
                tracingParameters.Add("streetType", streetType);
                tracingParameters.Add("streetDirection", streetDirection);
                tracingParameters.Add("streetQualifier", streetQualifier);
                tracingParameters.Add("localityName", localityName);
                tracingParameters.Add("provinceCode", provinceCode);
                tracingParameters.Add("localities", localities);
                tracingParameters.Add("notLocalities", notLocalities);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("centre", centre);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("extrapolate", extrapolate);
                tracingParameters.Add("parcelPoint", parcelPoint);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Occupants", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "occupants/addresses.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (addressString != null)
            {
                _queryParameters.Add(string.Format("addressString={0}", System.Uri.EscapeDataString(addressString)));
            }
            if (tags != null)
            {
                _queryParameters.Add(string.Format("tags={0}", System.Uri.EscapeDataString(tags)));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (interpolation != null)
            {
                _queryParameters.Add(string.Format("interpolation={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(interpolation, Client.SerializationSettings).Trim('"'))));
            }
            if (echo != null)
            {
                _queryParameters.Add(string.Format("echo={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(echo, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (autoComplete != null)
            {
                _queryParameters.Add(string.Format("autoComplete={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(autoComplete, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (minScore != null)
            {
                _queryParameters.Add(string.Format("minScore={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(minScore, Client.SerializationSettings).Trim('"'))));
            }
            if (matchPrecision != null)
            {
                _queryParameters.Add(string.Format("matchPrecision={0}", System.Uri.EscapeDataString(matchPrecision)));
            }
            if (matchPrecisionNot != null)
            {
                _queryParameters.Add(string.Format("matchPrecisionNot={0}", System.Uri.EscapeDataString(matchPrecisionNot)));
            }
            if (siteName != null)
            {
                _queryParameters.Add(string.Format("siteName={0}", System.Uri.EscapeDataString(siteName)));
            }
            if (unitDesignator != null)
            {
                _queryParameters.Add(string.Format("unitDesignator={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(unitDesignator, Client.SerializationSettings).Trim('"'))));
            }
            if (unitNumber != null)
            {
                _queryParameters.Add(string.Format("unitNumber={0}", System.Uri.EscapeDataString(unitNumber)));
            }
            if (unitNumberSuffix != null)
            {
                _queryParameters.Add(string.Format("unitNumberSuffix={0}", System.Uri.EscapeDataString(unitNumberSuffix)));
            }
            if (civicNumber != null)
            {
                _queryParameters.Add(string.Format("civicNumber={0}", System.Uri.EscapeDataString(civicNumber)));
            }
            if (civicNumberSuffix != null)
            {
                _queryParameters.Add(string.Format("civicNumberSuffix={0}", System.Uri.EscapeDataString(civicNumberSuffix)));
            }
            if (streetName != null)
            {
                _queryParameters.Add(string.Format("streetName={0}", System.Uri.EscapeDataString(streetName)));
            }
            if (streetType != null)
            {
                _queryParameters.Add(string.Format("streetType={0}", System.Uri.EscapeDataString(streetType)));
            }
            if (streetDirection != null)
            {
                _queryParameters.Add(string.Format("streetDirection={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(streetDirection, Client.SerializationSettings).Trim('"'))));
            }
            if (streetQualifier != null)
            {
                _queryParameters.Add(string.Format("streetQualifier={0}", System.Uri.EscapeDataString(streetQualifier)));
            }
            if (localityName != null)
            {
                _queryParameters.Add(string.Format("localityName={0}", System.Uri.EscapeDataString(localityName)));
            }
            if (provinceCode != null)
            {
                _queryParameters.Add(string.Format("provinceCode={0}", System.Uri.EscapeDataString(provinceCode)));
            }
            if (localities != null)
            {
                _queryParameters.Add(string.Format("localities={0}", System.Uri.EscapeDataString(localities)));
            }
            if (notLocalities != null)
            {
                _queryParameters.Add(string.Format("notLocalities={0}", System.Uri.EscapeDataString(notLocalities)));
            }
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (centre != null)
            {
                _queryParameters.Add(string.Format("centre={0}", System.Uri.EscapeDataString(centre)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (extrapolate != null)
            {
                _queryParameters.Add(string.Format("extrapolate={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(extrapolate, Client.SerializationSettings).Trim('"'))));
            }
            if (parcelPoint != null)
            {
                _queryParameters.Add(string.Format("parcelPoint={0}", System.Uri.EscapeDataString(parcelPoint)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find the site nearest to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents the site nearest a given point
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// Centre point of search. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#point
        /// target="_blank"&gt;point&lt;/a&gt;
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='excludeUnits'>
        /// If true, excludes sites that are units of a parent site
        /// </param>
        /// <param name='onlyCivic'>
        /// If true, excludes sites without a civic address
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Sites1WithHttpMessagesAsync(string outputFormat, string point, int? maxDistance = default(int?), int? outputSRS = 4326, string locationDescriptor = default(string), int? setBack = 0, bool? brief = false, bool? excludeUnits = false, bool? onlyCivic = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("excludeUnits", excludeUnits);
                tracingParameters.Add("onlyCivic", onlyCivic);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites1", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "sites/nearest.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (excludeUnits != null)
            {
                _queryParameters.Add(string.Format("excludeUnits={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(excludeUnits, Client.SerializationSettings).Trim('"'))));
            }
            if (onlyCivic != null)
            {
                _queryParameters.Add(string.Format("onlyCivic={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(onlyCivic, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find occupants of the site nearest to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents the closest occupant to a given point
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// The point (x,y) from which the nearest site will be identified. The
        /// coordinates must be specified in the same SRS as given by the 'outputSRS'
        /// parameter.
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='tags'>
        /// Example: schools;courts;employment&lt;br&gt;A list of tags separated by
        /// semicolons.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Occupants1WithHttpMessagesAsync(string outputFormat, string point, int? maxDistance = default(int?), string tags = default(string), int? outputSRS = 4326, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("tags", tags);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Occupants1", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "occupants/nearest.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (tags != null)
            {
                _queryParameters.Add(string.Format("tags={0}", System.Uri.EscapeDataString(tags)));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find nearest intersection to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents the closest intersection to a given point
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// Example: -122.377,50.121  The point (x,y) from which the nearest site will
        /// be identified. The coordinates must be specified in the same SRS as given
        /// by the 'outputSRS' parameter.
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='minDegree'>
        /// The minimum degree an intersection can have to be included in results. A
        /// dead-end has a degree of 1.
        /// </param>
        /// <param name='maxDegree'>
        /// The maximum degree an interesection can have to be included in results. A
        /// four-way stop has a degree of 4.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> IntersectionsWithHttpMessagesAsync(string outputFormat, string point, int? maxDistance = default(int?), int? outputSRS = 4326, int? minDegree = 2, int? maxDegree = 100, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("minDegree", minDegree);
                tracingParameters.Add("maxDegree", maxDegree);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Intersections", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "intersections/nearest.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (minDegree != null)
            {
                _queryParameters.Add(string.Format("minDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(minDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (maxDegree != null)
            {
                _queryParameters.Add(string.Format("maxDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find sites near to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents sites near a given point in the order of closest to farthest
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// The point (x,y) from which the nearby sites will be identified. The
        /// coordinates must be specified in the same SRS as given by the 'outputSRS'
        /// parameter.
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='excludeUnits'>
        /// If true, excludes sites that are units of a parent site
        /// </param>
        /// <param name='onlyCivic'>
        /// If true, excludes sites without a civic address
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Sites2WithHttpMessagesAsync(string outputFormat, string point, int? maxDistance = default(int?), int? outputSRS = 4326, int? maxResults = 1, string locationDescriptor = default(string), int? setBack = 0, bool? brief = false, bool? excludeUnits = false, bool? onlyCivic = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("excludeUnits", excludeUnits);
                tracingParameters.Add("onlyCivic", onlyCivic);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites2", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "sites/near.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (excludeUnits != null)
            {
                _queryParameters.Add(string.Format("excludeUnits={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(excludeUnits, Client.SerializationSettings).Trim('"'))));
            }
            if (onlyCivic != null)
            {
                _queryParameters.Add(string.Format("onlyCivic={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(onlyCivic, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find occupants of sites near to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents occupants near a given point in order of closest to farthest
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// The point (x,y) from which the nearest site will be identified. The
        /// coordinates must be specified in the same SRS as given by the 'outputSRS'
        /// parameter.
        /// </param>
        /// <param name='tags'>
        /// Example: schools;courts;employment&lt;br&gt;A list of tags separated by
        /// semicolons.
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Occupants2WithHttpMessagesAsync(string outputFormat, string point, string tags = default(string), int? maxDistance = default(int?), int? outputSRS = 4326, int? maxResults = 1, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("tags", tags);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Occupants2", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "occupants/near.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (tags != null)
            {
                _queryParameters.Add(string.Format("tags={0}", System.Uri.EscapeDataString(tags)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find intersections near to a geographic point
        /// </summary>
        /// <remarks>
        /// Represents intersections near a given point
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='point'>
        /// The point (x,y) from which the nearest site will be identified. The
        /// coordinates must be specified in the same SRS as given by the 'outputSRS'
        /// parameter.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgovapi-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxDistance'>
        /// The maximum distance (in metres) to search from the given point.  If not
        /// specified, the search distance is unlimited.
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='minDegree'>
        /// The minimum degree an intersection can have to be included in results. A
        /// dead-end has a degree of 1.
        /// </param>
        /// <param name='maxDegree'>
        /// The maximum degree an interesection can have to be included in results. A
        /// four-way stop has a degree of 4.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Intersections1WithHttpMessagesAsync(string outputFormat, string point, int outputSRS, int? maxDistance = default(int?), int? maxResults = 1, int? minDegree = 2, int? maxDegree = 100, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (point == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "point");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("point", point);
                tracingParameters.Add("maxDistance", maxDistance);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("minDegree", minDegree);
                tracingParameters.Add("maxDegree", maxDegree);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Intersections1", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "intersections/near.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (point != null)
            {
                _queryParameters.Add(string.Format("point={0}", System.Uri.EscapeDataString(point)));
            }
            if (maxDistance != null)
            {
                _queryParameters.Add(string.Format("maxDistance={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDistance, Client.SerializationSettings).Trim('"'))));
            }
            _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (minDegree != null)
            {
                _queryParameters.Add(string.Format("minDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(minDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (maxDegree != null)
            {
                _queryParameters.Add(string.Format("maxDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find sites in a geographic area
        /// </summary>
        /// <remarks>
        /// Represents sites within a given area
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='bbox'>
        /// A bounding box (xmin,ymin,xmax,ymax) used to limit the search area. See
        /// &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#bbox
        /// target="_blank"&gt;bbox&lt;/a&gt;
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='excludeUnits'>
        /// If true, excludes sites that are units of a parent site
        /// </param>
        /// <param name='onlyCivic'>
        /// If true, excludes sites without a civic address
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Sites3WithHttpMessagesAsync(string outputFormat, string bbox, int? outputSRS = 4326, int? maxResults = 1, string locationDescriptor = default(string), int? setBack = 0, bool? brief = false, bool? excludeUnits = false, bool? onlyCivic = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (bbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "bbox");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("excludeUnits", excludeUnits);
                tracingParameters.Add("onlyCivic", onlyCivic);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites3", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "sites/within.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (excludeUnits != null)
            {
                _queryParameters.Add(string.Format("excludeUnits={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(excludeUnits, Client.SerializationSettings).Trim('"'))));
            }
            if (onlyCivic != null)
            {
                _queryParameters.Add(string.Format("onlyCivic={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(onlyCivic, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find occupants of sites in a geographic area
        /// </summary>
        /// <remarks>
        /// Represents all occupants within a given area
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='bbox'>
        /// A bounding box (xmin,ymin,xmax,ymax) used to limit the search area. See
        /// &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#bbox
        /// target="_blank"&gt;bbox&lt;/a&gt;
        /// </param>
        /// <param name='tags'>
        /// Example: schools;courts;employment&lt;br&gt;A list of tags separated by
        /// semicolons.
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgovapi-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results to return.
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Occupants3WithHttpMessagesAsync(string outputFormat, string bbox, string tags = default(string), int? outputSRS = 4326, int? maxResults = 200, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (bbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "bbox");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("tags", tags);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Occupants3", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "occupants/within.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (tags != null)
            {
                _queryParameters.Add(string.Format("tags={0}", System.Uri.EscapeDataString(tags)));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Find intersections in a geographic area
        /// </summary>
        /// <remarks>
        /// Represents all intersections within a given area
        /// </remarks>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormattarget="_blank"&gt;outputFormat&lt;/a&gt;.
        /// Possible values include: 'json', 'geojson', 'xhtml', 'kml', 'gml', 'csv',
        /// 'shpz'
        /// </param>
        /// <param name='bbox'>
        /// A bounding box (xmin,ymin,xmax,ymax) used to limit the search area. See
        /// &lt;a
        /// href=https://github.com/bcgovapi-specs/blob/master/geocoder/glossary.md#bbox
        /// target="_blank"&gt;bbox&lt;/a&gt;
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='maxResults'>
        /// The maximum number of search results
        /// </param>
        /// <param name='minDegree'>
        /// The minimum degree an intersection can have to be included in results. A
        /// dead-end has a degree of 1.
        /// </param>
        /// <param name='maxDegree'>
        /// The maximum degree an interesection can have to be included in results. A
        /// four-way stop has a degree of 4.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Intersections2WithHttpMessagesAsync(string outputFormat, string bbox, int? outputSRS = 4326, int? maxResults = 200, int? minDegree = 2, int? maxDegree = 100, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            if (bbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "bbox");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("maxResults", maxResults);
                tracingParameters.Add("minDegree", minDegree);
                tracingParameters.Add("maxDegree", maxDegree);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Intersections2", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "intersections/within.{outputFormat}").ToString();
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (maxResults != null)
            {
                _queryParameters.Add(string.Format("maxResults={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxResults, Client.SerializationSettings).Trim('"'))));
            }
            if (minDegree != null)
            {
                _queryParameters.Add(string.Format("minDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(minDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (maxDegree != null)
            {
                _queryParameters.Add(string.Format("maxDegree={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxDegree, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Represents all subsites of a given site
        /// </summary>
        /// <remarks>
        /// Represents all subsites of a given site
        /// </remarks>
        /// <param name='siteID'>
        /// A unique, but not immutable, site identifier.
        /// </param>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Sites4WithHttpMessagesAsync(string siteID, string outputFormat, int? outputSRS = 4326, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (siteID == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "siteID");
            }
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("siteID", siteID);
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites4", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "sites/{siteID}/subsites.{outputFormat}").ToString();
            _url = _url.Replace("{siteID}", System.Uri.EscapeDataString(siteID));
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get a site by its unique ID
        /// </summary>
        /// <remarks>
        /// Represents an individual site
        /// </remarks>
        /// <param name='siteID'>
        /// A unique, but not immutable, site identifier.
        /// </param>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Sites5WithHttpMessagesAsync(string siteID, string outputFormat, int? outputSRS = 4326, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (siteID == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "siteID");
            }
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("siteID", siteID);
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Sites5", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "sites/{siteID}.{outputFormat}").ToString();
            _url = _url.Replace("{siteID}", System.Uri.EscapeDataString(siteID));
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get an occupant (of a site) by its unique ID
        /// </summary>
        /// <remarks>
        /// Represents an individual occupant
        /// </remarks>
        /// <param name='occupantID'>
        /// Occupant identifier
        /// </param>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgovapi-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='locationDescriptor'>
        /// Describes the nature of the address location. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#locationDescriptor
        /// target="_blank"&gt;locationDescriptor&lt;/a&gt;. Possible values include:
        /// 'any', 'accessPoint', 'frontDoorPoint', 'parcelPoint', 'rooftopPoint',
        /// 'routingPoint'
        /// </param>
        /// <param name='brief'>
        /// If true, include only basic match and address details in results. Not
        /// supported for shp, csv, and gml formats.
        /// </param>
        /// <param name='setBack'>
        /// The distance to move the accessPoint away from the curb and towards the
        /// inside of the parcel (in metres). Ignored if locationDescriptor not set to
        /// accessPoint.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Occupants4WithHttpMessagesAsync(string occupantID, string outputFormat, int? outputSRS = 4326, string locationDescriptor = default(string), bool? brief = false, int? setBack = 0, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (occupantID == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "occupantID");
            }
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("occupantID", occupantID);
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("locationDescriptor", locationDescriptor);
                tracingParameters.Add("brief", brief);
                tracingParameters.Add("setBack", setBack);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Occupants4", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "occupants/{occupantID}.{outputFormat}").ToString();
            _url = _url.Replace("{occupantID}", System.Uri.EscapeDataString(occupantID));
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (locationDescriptor != null)
            {
                _queryParameters.Add(string.Format("locationDescriptor={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(locationDescriptor, Client.SerializationSettings).Trim('"'))));
            }
            if (brief != null)
            {
                _queryParameters.Add(string.Format("brief={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(brief, Client.SerializationSettings).Trim('"'))));
            }
            if (setBack != null)
            {
                _queryParameters.Add(string.Format("setBack={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(setBack, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get a comma-separated string of all pids for a given site
        /// </summary>
        /// <remarks>
        /// Represents all parcel identifiers associated with an individual site
        /// </remarks>
        /// <param name='siteID'>
        /// A unique, but not immutable, site identifier.
        /// </param>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> ParcelsWithHttpMessagesAsync(string siteID, string outputFormat, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (siteID == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "siteID");
            }
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("siteID", siteID);
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Parcels", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "parcels/pids/{siteID}.{outputFormat}").ToString();
            _url = _url.Replace("{siteID}", System.Uri.EscapeDataString(siteID));
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get an intersection by its unique ID
        /// </summary>
        /// <remarks>
        /// Represents a individual intersection
        /// </remarks>
        /// <param name='intersectionID'>
        /// A unique intersection identifier
        /// </param>
        /// <param name='outputFormat'>
        /// Results format. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputFormat
        /// target="_blank"&gt;outputFormat&lt;/a&gt;. Possible values include: 'json',
        /// 'geojson', 'xhtml', 'kml', 'gml', 'csv', 'shpz'
        /// </param>
        /// <param name='outputSRS'>
        /// The EPSG code of the spatial reference system (SRS) to use for output
        /// geometries. See &lt;a
        /// href=https://github.com/bcgov/api-specs/blob/master/geocoder/glossary.md#outputSRS
        /// target="_blank"&gt;outputSRS&lt;/a&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> Intersections3WithHttpMessagesAsync(string intersectionID, string outputFormat, int? outputSRS = 4326, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (intersectionID == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "intersectionID");
            }
            if (outputFormat == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "outputFormat");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("intersectionID", intersectionID);
                tracingParameters.Add("outputFormat", outputFormat);
                tracingParameters.Add("outputSRS", outputSRS);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Intersections3", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "intersections/{intersectionID}.{outputFormat}").ToString();
            _url = _url.Replace("{intersectionID}", System.Uri.EscapeDataString(intersectionID));
            _url = _url.Replace("{outputFormat}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputFormat, Client.SerializationSettings).Trim('"')));
            List<string> _queryParameters = new List<string>();
            if (outputSRS != null)
            {
                _queryParameters.Add(string.Format("outputSRS={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputSRS, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
